using System;
using System.Collections.Generic;
using Temporal.Serialization;
using Temporal.WorkflowClient.Interceptors;

namespace Temporal.WorkflowClient
{
    public class TemporalClientConfiguration
    {
        #region Static APIs

        /// <summary>
        /// Creates a new <c>TemporalClientConfiguration</c> initialized with default settings for use with
        /// a local Temporal server installation.<br/>
        /// To create a <c>TemporalClientConfiguration</c> with custom settings, use the ctor.
        /// </summary>
        public static TemporalClientConfiguration ForLocalHost()
        {
            return new TemporalClientConfiguration();
        }

        /// <summary>
        /// Creates a new <c>TemporalClientConfiguration</c> initialized with default settings for use with
        /// a the Temporal Cloud frontend.<br/>
        /// To create a <c>TemporalClientConfiguration</c> with custom settings, use the ctor.
        /// </summary>
        /// <param name="namespace">The Temporal namespace to use by the clients based on the configuration being created.</param>
        public static TemporalClientConfiguration ForTemporalCloud(string @namespace)
        {
            Temporal.Util.Validate.NotNull(@namespace);

            return new TemporalClientConfiguration()
            {
                ServiceHost = "???",
                ServicePort = -1,
                IsHttpsEnabled = true,
                Namespace = @namespace,
                ClientIdentity = null
            };
        }

        public static void Validate(TemporalClientConfiguration config)
        {
            Temporal.Util.Validate.NotNull(config);
            Temporal.Util.Validate.NotNullOrWhitespace(config.ServiceHost);
            Temporal.Util.Validate.NotNullOrWhitespace(config.Namespace);

            if (config.ServicePort <= 0)
            {
                throw new ArgumentException($"{nameof(config)}.{nameof(config.ServicePort)} must be a posivite"
                                          + $" value, but {config.ServicePort} was specified.");
            }

            if (config.ClientIdentity != null && String.IsNullOrWhiteSpace(config.ClientIdentity))
            {
                throw new ArgumentException($"{nameof(config)}.{nameof(config.ClientIdentity)} must be either not set (=null) or it"
                                          + $" must be a non-whitespace-only string, however, \"{config.ClientIdentity}\" was specified.");
            }
        }

        #endregion Static APIs

        public TemporalClientConfiguration()
        {
            ServiceHost = "127.0.0.1";  // Do not use "localhost" to avoid the IPv4 resolution wait
            ServicePort = 7233;
            IsHttpsEnabled = false;
            Namespace = "default";
            ClientIdentity = null;
        }

        public string ServiceHost { get; init; }
        public int ServicePort { get; init; }
        public bool IsHttpsEnabled { get; init; }
        public string Namespace { get; init; }
        public string ClientIdentity { get; init; }

        /// <summary>
        /// Factory receives the `IWorkflowHandle` for which the payload converter is being constructed and returns
        /// a new non-null data converter to be applied to all calls made by the client for the specific `IWorkflowHandle` instance.
        /// </summary>
        public Func<ServiceInvocationPipelineItemFactoryArguments, IPayloadConverter> PayloadConverterFactory { get; init; }

        /// <summary>
        /// Factory receives the `IWorkflowHandle` for which the payload codec is being constructed and returns
        /// a new non-null payload converter to be applied to all calls made by the client for the specific `IWorkflowHandle` instance.
        /// </summary>
        public Func<ServiceInvocationPipelineItemFactoryArguments, IPayloadCodec> PayloadCodecFactory { get; init; }


        /// <summary>
        /// Factory receives the `IWorkflowHandle` for which the interceptors are being constructed and list of all
        /// already existing interceptors, i.e. the interceptors generated by the system. That received interceptor
        /// list is never null, but may be empty. The interceptor list does NOT include the final "sink" interceptor
        /// - that will always remain LAST and the factory shall not be able to affect that. However, the list DOES
        /// include all other system interceptors, if any (e.g. the ones that implement distributed tracing).
        /// The factory may modify that list any way it wants, including removing system interceptors (expect
        /// the aforementioned sink) or adding new interceptors before or after.
        /// Nulls must not be added to the list.
        /// </summary>
        public Action<ServiceInvocationPipelineItemFactoryArguments, IList<ITemporalClientInterceptor>> ClientInterceptorFactory { get; init; }

        // . . .
    }
}
